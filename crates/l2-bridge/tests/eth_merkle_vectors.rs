//! Ethereum Merkle Receipt Proof Test Vectors.
//!
//! This file contains test vectors for verifying Ethereum receipt inclusion proofs.
//! The vectors are synthetic but structurally valid for testing the verification logic.
//!
//! ## Test Coverage
//!
//! - Valid proof verification
//! - Mutated proof node detection
//! - Wrong log index detection
//! - Wrong topic0 detection
//! - Wrong contract address detection
//! - Wrong data hash detection
//!
//! ## Note on Synthetic Vectors
//!
//! These vectors are constructed synthetically because:
//! 1. Real Ethereum data requires RPC access
//! 2. The verification logic is deterministic
//! 3. Unit tests focus on code correctness, not real-world data
//!
//! For integration testing with real Ethereum data, use the external proof API
//! with real proofs generated by an Ethereum full node.

#![cfg(feature = "merkle-proofs")]

use l2_bridge::eth_merkle::{verify_eth_receipt_merkle_proof, EthMerkleVerifyError};
use l2_core::{EthReceiptMerkleProofV1, ExternalChainId};

/// Helper to create a minimal valid Ethereum block header RLP.
///
/// Block header fields:
/// 0: parentHash (32 bytes)
/// 1: uncleHash (32 bytes)
/// 2: coinbase (20 bytes)
/// 3: stateRoot (32 bytes)
/// 4: transactionsRoot (32 bytes)
/// 5: receiptsRoot (32 bytes) <- This is what we verify against
/// 6: logsBloom (256 bytes)
/// 7: difficulty (variable)
/// 8: number (variable)
/// 9: gasLimit (variable)
/// 10: gasUsed (variable)
/// 11: timestamp (variable)
/// 12: extraData (variable)
/// 13: mixHash (32 bytes)
/// 14: nonce (8 bytes)
fn create_block_header_rlp(receipts_root: [u8; 32]) -> Vec<u8> {
    // Simplified header with just the fields we need
    // Using RLP encoding manually for test predictability
    
    let mut header = Vec::new();
    
    // We'll encode a list with minimal valid fields
    // parentHash: 32 bytes of zeros
    let parent_hash = [0u8; 32];
    // uncleHash: 32 bytes
    let uncle_hash = [0u8; 32];
    // coinbase: 20 bytes
    let coinbase = [0u8; 20];
    // stateRoot: 32 bytes
    let state_root = [0u8; 32];
    // transactionsRoot: 32 bytes
    let tx_root = [0u8; 32];
    // receiptsRoot: 32 bytes (provided)
    // logsBloom: 256 bytes of zeros
    let logs_bloom = [0u8; 256];
    // difficulty: 1 (single byte)
    let difficulty = 1u8;
    // number: block number (e.g., 18000000)
    let block_number: u64 = 18_000_000;
    // gasLimit: some value
    let gas_limit: u64 = 30_000_000;
    // gasUsed: some value
    let gas_used: u64 = 15_000_000;
    // timestamp: some value
    let timestamp: u64 = 1700000000;
    // extraData: empty
    // mixHash: 32 bytes
    let mix_hash = [0u8; 32];
    // nonce: 8 bytes
    let nonce = [0u8; 8];
    
    // Encode each field as RLP
    fn encode_bytes(data: &[u8]) -> Vec<u8> {
        if data.len() == 1 && data[0] < 0x80 {
            data.to_vec()
        } else if data.len() < 56 {
            let mut out = vec![0x80 + data.len() as u8];
            out.extend_from_slice(data);
            out
        } else {
            let len_bytes = encode_length(data.len());
            let mut out = vec![0xb7 + len_bytes.len() as u8];
            out.extend(len_bytes);
            out.extend_from_slice(data);
            out
        }
    }
    
    fn encode_length(len: usize) -> Vec<u8> {
        if len < 256 {
            vec![len as u8]
        } else {
            let mut bytes = Vec::new();
            let mut n = len;
            while n > 0 {
                bytes.insert(0, (n & 0xff) as u8);
                n >>= 8;
            }
            bytes
        }
    }
    
    fn encode_uint(n: u64) -> Vec<u8> {
        if n == 0 {
            return vec![0x80]; // Empty string for 0
        }
        let mut bytes = Vec::new();
        let mut val = n;
        while val > 0 {
            bytes.insert(0, (val & 0xff) as u8);
            val >>= 8;
        }
        encode_bytes(&bytes)
    }
    
    // Build header fields
    let mut fields = Vec::new();
    fields.extend(encode_bytes(&parent_hash));
    fields.extend(encode_bytes(&uncle_hash));
    fields.extend(encode_bytes(&coinbase));
    fields.extend(encode_bytes(&state_root));
    fields.extend(encode_bytes(&tx_root));
    fields.extend(encode_bytes(&receipts_root));
    fields.extend(encode_bytes(&logs_bloom));
    fields.extend(encode_uint(difficulty as u64));
    fields.extend(encode_uint(block_number));
    fields.extend(encode_uint(gas_limit));
    fields.extend(encode_uint(gas_used));
    fields.extend(encode_uint(timestamp));
    fields.extend(encode_bytes(&[])); // extraData
    fields.extend(encode_bytes(&mix_hash));
    fields.extend(encode_bytes(&nonce));
    
    // Encode as list
    if fields.len() < 56 {
        header.push(0xc0 + fields.len() as u8);
    } else {
        let len_bytes = encode_length(fields.len());
        header.push(0xf7 + len_bytes.len() as u8);
        header.extend(len_bytes);
    }
    header.extend(fields);
    
    header
}

/// Create a minimal receipt RLP with a single log.
fn create_receipt_rlp(contract: [u8; 20], topics: &[[u8; 32]], data: &[u8]) -> Vec<u8> {
    fn encode_bytes(data: &[u8]) -> Vec<u8> {
        if data.is_empty() {
            return vec![0x80];
        }
        if data.len() == 1 && data[0] < 0x80 {
            data.to_vec()
        } else if data.len() < 56 {
            let mut out = vec![0x80 + data.len() as u8];
            out.extend_from_slice(data);
            out
        } else {
            let len_bytes = encode_length(data.len());
            let mut out = vec![0xb7 + len_bytes.len() as u8];
            out.extend(len_bytes);
            out.extend_from_slice(data);
            out
        }
    }
    
    fn encode_length(len: usize) -> Vec<u8> {
        if len < 256 {
            vec![len as u8]
        } else {
            let mut bytes = Vec::new();
            let mut n = len;
            while n > 0 {
                bytes.insert(0, (n & 0xff) as u8);
                n >>= 8;
            }
            bytes
        }
    }
    
    fn encode_list(items: Vec<u8>) -> Vec<u8> {
        if items.len() < 56 {
            let mut out = vec![0xc0 + items.len() as u8];
            out.extend(items);
            out
        } else {
            let len_bytes = encode_length(items.len());
            let mut out = vec![0xf7 + len_bytes.len() as u8];
            out.extend(len_bytes);
            out.extend(items);
            out
        }
    }
    
    // Build log: [address, topics, data]
    let mut log_fields = Vec::new();
    log_fields.extend(encode_bytes(&contract));
    
    // Topics list
    let mut topics_items = Vec::new();
    for topic in topics {
        topics_items.extend(encode_bytes(topic));
    }
    log_fields.extend(encode_list(topics_items));
    
    // Data
    log_fields.extend(encode_bytes(data));
    
    let log_rlp = encode_list(log_fields);
    
    // Build receipt: [status, cumulativeGasUsed, logsBloom, logs]
    let mut receipt_fields = Vec::new();
    
    // Status: 1 (success)
    receipt_fields.push(0x01);
    
    // Cumulative gas used: some value
    receipt_fields.extend(encode_bytes(&[0x01, 0x00, 0x00])); // 65536
    
    // Logs bloom: 256 zeros
    receipt_fields.extend(encode_bytes(&[0u8; 256]));
    
    // Logs: list containing our log
    receipt_fields.extend(encode_list(log_rlp));
    
    encode_list(receipt_fields)
}

/// Compute keccak256 hash using sha3 crate.
fn keccak256(data: &[u8]) -> [u8; 32] {
    use sha3::{Digest, Keccak256};
    let mut hasher = Keccak256::new();
    hasher.update(data);
    let result = hasher.finalize();
    let mut hash = [0u8; 32];
    hash.copy_from_slice(&result);
    hash
}

/// Create a simple MPT proof for testing.
/// 
/// For a single-element trie with key = rlp(0), the proof is a single leaf node.
fn create_simple_mpt_proof(receipt_rlp: &[u8]) -> (Vec<Vec<u8>>, [u8; 32]) {
    // For tx_index = 0, the key is 0x80 (RLP of empty string / 0)
    // A leaf node with this key would be:
    // [hp_encode(key, leaf=true), value]
    // HP encoding: for key [] (empty nibbles), leaf prefix is 0x20
    
    fn encode_bytes(data: &[u8]) -> Vec<u8> {
        if data.is_empty() {
            return vec![0x80];
        }
        if data.len() == 1 && data[0] < 0x80 {
            data.to_vec()
        } else if data.len() < 56 {
            let mut out = vec![0x80 + data.len() as u8];
            out.extend_from_slice(data);
            out
        } else {
            let len_bytes = {
                let len = data.len();
                if len < 256 {
                    vec![len as u8]
                } else {
                    let mut bytes = Vec::new();
                    let mut n = len;
                    while n > 0 {
                        bytes.insert(0, (n & 0xff) as u8);
                        n >>= 8;
                    }
                    bytes
                }
            };
            let mut out = vec![0xb7 + len_bytes.len() as u8];
            out.extend(len_bytes);
            out.extend_from_slice(data);
            out
        }
    }
    
    fn encode_list(items: Vec<u8>) -> Vec<u8> {
        let len = items.len();
        if len < 56 {
            let mut out = vec![0xc0 + len as u8];
            out.extend(items);
            out
        } else {
            let len_bytes = {
                if len < 256 {
                    vec![len as u8]
                } else {
                    let mut bytes = Vec::new();
                    let mut n = len;
                    while n > 0 {
                        bytes.insert(0, (n & 0xff) as u8);
                        n >>= 8;
                    }
                    bytes
                }
            };
            let mut out = vec![0xf7 + len_bytes.len() as u8];
            out.extend(len_bytes);
            out.extend(items);
            out
        }
    }
    
    // For tx_index = 0, the RLP key is 0x80
    // The nibbles are: [8, 0]
    // HP encoding for leaf with even nibbles [8, 0]: prefix 0x20, then 0x80
    let hp_encoded_key = vec![0x20, 0x80];
    
    // Build leaf node: [hp_key, value]
    let mut leaf_items = Vec::new();
    leaf_items.extend(encode_bytes(&hp_encoded_key));
    leaf_items.extend(encode_bytes(receipt_rlp));
    
    let leaf_node = encode_list(leaf_items);
    
    // The root is the keccak256 of the leaf node
    let root = keccak256(&leaf_node);
    
    (vec![leaf_node], root)
}

/// Test vector 1: Valid ERC20 Transfer event proof.
#[test]
fn test_valid_erc20_transfer_proof() {
    // ERC20 Transfer event signature: Transfer(address,address,uint256)
    // keccak256("Transfer(address,address,uint256)") = 0xddf252ad...
    let transfer_topic0: [u8; 32] = [
        0xdd, 0xf2, 0x52, 0xad, 0x1b, 0xe2, 0xc8, 0x9b,
        0x69, 0xc2, 0xb0, 0x68, 0xfc, 0x37, 0x8d, 0xaa,
        0x95, 0x2b, 0xa7, 0xf1, 0x63, 0xc4, 0xa1, 0x16,
        0x28, 0xf5, 0x5a, 0x4d, 0xf5, 0x23, 0xb3, 0xef,
    ];
    
    // USDC contract address (example)
    let contract: [u8; 20] = [
        0xA0, 0xb8, 0x69, 0x91, 0xc6, 0x21, 0x8b, 0x36,
        0xc1, 0xd1, 0x9D, 0x4a, 0x2e, 0x9E, 0xb0, 0xcE,
        0x36, 0x06, 0xeB, 0x48,
    ];
    
    // From address (indexed)
    let from_topic: [u8; 32] = {
        let mut t = [0u8; 32];
        t[12..].copy_from_slice(&[0xAA; 20]);
        t
    };
    
    // To address (indexed)  
    let to_topic: [u8; 32] = {
        let mut t = [0u8; 32];
        t[12..].copy_from_slice(&[0xBB; 20]);
        t
    };
    
    // Data: amount = 1000000 (1 USDC with 6 decimals)
    let data: Vec<u8> = {
        let mut d = [0u8; 32];
        d[31] = 0x40; // 64 in last byte = 1000000 / 15625
        d[30] = 0x42; // approximation for demo
        d[29] = 0x0f;
        d.to_vec()
    };
    
    // Create receipt RLP
    let topics = [transfer_topic0, from_topic, to_topic];
    let receipt_rlp = create_receipt_rlp(contract, &topics, &data);
    
    // Create MPT proof
    let (proof_nodes, receipts_root) = create_simple_mpt_proof(&receipt_rlp);
    
    // Create block header with this receipts root
    let header_rlp = create_block_header_rlp(receipts_root);
    let block_hash = keccak256(&header_rlp);
    
    // Compute data hash using blake3
    let data_hash: [u8; 32] = blake3::hash(&data).into();
    
    // Build the proof struct
    let proof = EthReceiptMerkleProofV1 {
        chain: ExternalChainId::EthereumMainnet,
        tx_hash: [0x11; 32],
        log_index: 0,
        contract,
        topic0: transfer_topic0,
        data_hash,
        block_number: 18_000_000,
        block_hash,
        header_rlp,
        tx_index: 0,
        receipt_rlp,
        proof_nodes,
        confirmations: Some(12),
        tip_block_number: Some(18_000_012),
    };
    
    // Verify the proof
    let result = verify_eth_receipt_merkle_proof(&proof);
    assert!(result.is_ok(), "valid proof should verify: {:?}", result.err());
    
    let verified = result.unwrap();
    assert_eq!(verified.block_number, 18_000_000);
    assert_eq!(verified.log_index, 0);
    assert_eq!(verified.contract, contract);
    assert_eq!(verified.topic0, transfer_topic0);
    assert_eq!(verified.data_hash, data_hash);
}

/// Test vector 2: Valid Deposit event proof (simulating a bridge deposit).
#[test]
fn test_valid_deposit_proof() {
    // Deposit(address indexed from, uint256 amount, bytes32 ippanRecipient)
    // Synthetic topic0 for testing
    let deposit_topic0: [u8; 32] = [
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
    ];
    
    // Bridge contract address
    let contract: [u8; 20] = [0xCC; 20];
    
    // From address (indexed)
    let from_topic: [u8; 32] = {
        let mut t = [0u8; 32];
        t[12..].copy_from_slice(&[0xDD; 20]);
        t
    };
    
    // Data: amount + ippanRecipient
    let data: Vec<u8> = {
        let mut d = Vec::new();
        // amount: 32 bytes
        d.extend_from_slice(&[0u8; 24]);
        d.extend_from_slice(&[0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x42, 0x40]); // 1000000
        // ippanRecipient: 32 bytes
        d.extend_from_slice(&[0xEE; 32]);
        d
    };
    
    let topics = [deposit_topic0, from_topic];
    let receipt_rlp = create_receipt_rlp(contract, &topics, &data);
    
    let (proof_nodes, receipts_root) = create_simple_mpt_proof(&receipt_rlp);
    let header_rlp = create_block_header_rlp(receipts_root);
    let block_hash = keccak256(&header_rlp);
    let data_hash: [u8; 32] = blake3::hash(&data).into();
    
    let proof = EthReceiptMerkleProofV1 {
        chain: ExternalChainId::EthereumSepolia,
        tx_hash: [0x22; 32],
        log_index: 0,
        contract,
        topic0: deposit_topic0,
        data_hash,
        block_number: 5_000_000,
        block_hash,
        header_rlp,
        tx_index: 0,
        receipt_rlp,
        proof_nodes,
        confirmations: Some(6),
        tip_block_number: Some(5_000_006),
    };
    
    let result = verify_eth_receipt_merkle_proof(&proof);
    assert!(result.is_ok(), "valid deposit proof should verify: {:?}", result.err());
}

/// Test: Mutated proof node should fail verification.
#[test]
fn test_mutated_proof_node_fails() {
    let topic0: [u8; 32] = [0xAA; 32];
    let contract: [u8; 20] = [0xBB; 20];
    let data = vec![0x01, 0x02, 0x03, 0x04];
    
    let topics = [topic0];
    let receipt_rlp = create_receipt_rlp(contract, &topics, &data);
    let (mut proof_nodes, receipts_root) = create_simple_mpt_proof(&receipt_rlp);
    let header_rlp = create_block_header_rlp(receipts_root);
    let block_hash = keccak256(&header_rlp);
    let data_hash: [u8; 32] = blake3::hash(&data).into();
    
    // Mutate the proof node
    if !proof_nodes.is_empty() && !proof_nodes[0].is_empty() {
        proof_nodes[0][0] ^= 0xFF; // Flip bits in first byte
    }
    
    let proof = EthReceiptMerkleProofV1 {
        chain: ExternalChainId::EthereumMainnet,
        tx_hash: [0x33; 32],
        log_index: 0,
        contract,
        topic0,
        data_hash,
        block_number: 18_000_000,
        block_hash,
        header_rlp,
        tx_index: 0,
        receipt_rlp,
        proof_nodes,
        confirmations: Some(12),
        tip_block_number: None,
    };
    
    let result = verify_eth_receipt_merkle_proof(&proof);
    assert!(result.is_err(), "mutated proof should fail");
    
    match result.err().unwrap() {
        EthMerkleVerifyError::MptProofFailed(_) => {}
        e => panic!("expected MptProofFailed, got: {:?}", e),
    }
}

/// Test: Wrong log index should fail verification.
#[test]
fn test_wrong_log_index_fails() {
    let topic0: [u8; 32] = [0xAA; 32];
    let contract: [u8; 20] = [0xBB; 20];
    let data = vec![0x01, 0x02, 0x03, 0x04];
    
    let topics = [topic0];
    let receipt_rlp = create_receipt_rlp(contract, &topics, &data);
    let (proof_nodes, receipts_root) = create_simple_mpt_proof(&receipt_rlp);
    let header_rlp = create_block_header_rlp(receipts_root);
    let block_hash = keccak256(&header_rlp);
    let data_hash: [u8; 32] = blake3::hash(&data).into();
    
    let proof = EthReceiptMerkleProofV1 {
        chain: ExternalChainId::EthereumMainnet,
        tx_hash: [0x44; 32],
        log_index: 1, // Wrong! Receipt only has 1 log (index 0)
        contract,
        topic0,
        data_hash,
        block_number: 18_000_000,
        block_hash,
        header_rlp,
        tx_index: 0,
        receipt_rlp,
        proof_nodes,
        confirmations: Some(12),
        tip_block_number: None,
    };
    
    let result = verify_eth_receipt_merkle_proof(&proof);
    assert!(result.is_err(), "wrong log index should fail");
    
    match result.err().unwrap() {
        EthMerkleVerifyError::LogIndexOutOfBounds { index: 1, count: 1 } => {}
        e => panic!("expected LogIndexOutOfBounds, got: {:?}", e),
    }
}

/// Test: Wrong topic0 should fail verification.
#[test]
fn test_wrong_topic0_fails() {
    let topic0: [u8; 32] = [0xAA; 32];
    let contract: [u8; 20] = [0xBB; 20];
    let data = vec![0x01, 0x02, 0x03, 0x04];
    
    let topics = [topic0];
    let receipt_rlp = create_receipt_rlp(contract, &topics, &data);
    let (proof_nodes, receipts_root) = create_simple_mpt_proof(&receipt_rlp);
    let header_rlp = create_block_header_rlp(receipts_root);
    let block_hash = keccak256(&header_rlp);
    let data_hash: [u8; 32] = blake3::hash(&data).into();
    
    let wrong_topic0: [u8; 32] = [0xFF; 32]; // Different from actual topic0
    
    let proof = EthReceiptMerkleProofV1 {
        chain: ExternalChainId::EthereumMainnet,
        tx_hash: [0x55; 32],
        log_index: 0,
        contract,
        topic0: wrong_topic0, // Wrong!
        data_hash,
        block_number: 18_000_000,
        block_hash,
        header_rlp,
        tx_index: 0,
        receipt_rlp,
        proof_nodes,
        confirmations: Some(12),
        tip_block_number: None,
    };
    
    let result = verify_eth_receipt_merkle_proof(&proof);
    assert!(result.is_err(), "wrong topic0 should fail");
    
    match result.err().unwrap() {
        EthMerkleVerifyError::Topic0Mismatch { .. } => {}
        e => panic!("expected Topic0Mismatch, got: {:?}", e),
    }
}

/// Test: Wrong contract address should fail verification.
#[test]
fn test_wrong_contract_fails() {
    let topic0: [u8; 32] = [0xAA; 32];
    let contract: [u8; 20] = [0xBB; 20];
    let data = vec![0x01, 0x02, 0x03, 0x04];
    
    let topics = [topic0];
    let receipt_rlp = create_receipt_rlp(contract, &topics, &data);
    let (proof_nodes, receipts_root) = create_simple_mpt_proof(&receipt_rlp);
    let header_rlp = create_block_header_rlp(receipts_root);
    let block_hash = keccak256(&header_rlp);
    let data_hash: [u8; 32] = blake3::hash(&data).into();
    
    let wrong_contract: [u8; 20] = [0xFF; 20]; // Different from actual contract
    
    let proof = EthReceiptMerkleProofV1 {
        chain: ExternalChainId::EthereumMainnet,
        tx_hash: [0x66; 32],
        log_index: 0,
        contract: wrong_contract, // Wrong!
        topic0,
        data_hash,
        block_number: 18_000_000,
        block_hash,
        header_rlp,
        tx_index: 0,
        receipt_rlp,
        proof_nodes,
        confirmations: Some(12),
        tip_block_number: None,
    };
    
    let result = verify_eth_receipt_merkle_proof(&proof);
    assert!(result.is_err(), "wrong contract should fail");
    
    match result.err().unwrap() {
        EthMerkleVerifyError::ContractMismatch { .. } => {}
        e => panic!("expected ContractMismatch, got: {:?}", e),
    }
}

/// Test: Wrong data hash should fail verification.
#[test]
fn test_wrong_data_hash_fails() {
    let topic0: [u8; 32] = [0xAA; 32];
    let contract: [u8; 20] = [0xBB; 20];
    let data = vec![0x01, 0x02, 0x03, 0x04];
    
    let topics = [topic0];
    let receipt_rlp = create_receipt_rlp(contract, &topics, &data);
    let (proof_nodes, receipts_root) = create_simple_mpt_proof(&receipt_rlp);
    let header_rlp = create_block_header_rlp(receipts_root);
    let block_hash = keccak256(&header_rlp);
    
    let wrong_data_hash: [u8; 32] = [0xFF; 32]; // Not the actual blake3 hash
    
    let proof = EthReceiptMerkleProofV1 {
        chain: ExternalChainId::EthereumMainnet,
        tx_hash: [0x77; 32],
        log_index: 0,
        contract,
        topic0,
        data_hash: wrong_data_hash, // Wrong!
        block_number: 18_000_000,
        block_hash,
        header_rlp,
        tx_index: 0,
        receipt_rlp,
        proof_nodes,
        confirmations: Some(12),
        tip_block_number: None,
    };
    
    let result = verify_eth_receipt_merkle_proof(&proof);
    assert!(result.is_err(), "wrong data hash should fail");
    
    match result.err().unwrap() {
        EthMerkleVerifyError::DataHashMismatch { .. } => {}
        e => panic!("expected DataHashMismatch, got: {:?}", e),
    }
}

/// Test: Block hash mismatch should fail verification.
#[test]
fn test_block_hash_mismatch_fails() {
    let topic0: [u8; 32] = [0xAA; 32];
    let contract: [u8; 20] = [0xBB; 20];
    let data = vec![0x01, 0x02, 0x03, 0x04];
    
    let topics = [topic0];
    let receipt_rlp = create_receipt_rlp(contract, &topics, &data);
    let (proof_nodes, receipts_root) = create_simple_mpt_proof(&receipt_rlp);
    let header_rlp = create_block_header_rlp(receipts_root);
    // Don't compute actual hash - use wrong one
    let wrong_block_hash: [u8; 32] = [0xFF; 32];
    let data_hash: [u8; 32] = blake3::hash(&data).into();
    
    let proof = EthReceiptMerkleProofV1 {
        chain: ExternalChainId::EthereumMainnet,
        tx_hash: [0x88; 32],
        log_index: 0,
        contract,
        topic0,
        data_hash,
        block_number: 18_000_000,
        block_hash: wrong_block_hash, // Wrong!
        header_rlp,
        tx_index: 0,
        receipt_rlp,
        proof_nodes,
        confirmations: Some(12),
        tip_block_number: None,
    };
    
    let result = verify_eth_receipt_merkle_proof(&proof);
    assert!(result.is_err(), "wrong block hash should fail");
    
    match result.err().unwrap() {
        EthMerkleVerifyError::BlockHashMismatch { .. } => {}
        e => panic!("expected BlockHashMismatch, got: {:?}", e),
    }
}

/// Test: Empty proof nodes should fail.
#[test]
fn test_empty_proof_nodes_fails() {
    let topic0: [u8; 32] = [0xAA; 32];
    let contract: [u8; 20] = [0xBB; 20];
    let data = vec![0x01, 0x02, 0x03, 0x04];
    
    let topics = [topic0];
    let receipt_rlp = create_receipt_rlp(contract, &topics, &data);
    let (_, receipts_root) = create_simple_mpt_proof(&receipt_rlp);
    let header_rlp = create_block_header_rlp(receipts_root);
    let block_hash = keccak256(&header_rlp);
    let data_hash: [u8; 32] = blake3::hash(&data).into();
    
    let proof = EthReceiptMerkleProofV1 {
        chain: ExternalChainId::EthereumMainnet,
        tx_hash: [0x99; 32],
        log_index: 0,
        contract,
        topic0,
        data_hash,
        block_number: 18_000_000,
        block_hash,
        header_rlp,
        tx_index: 0,
        receipt_rlp,
        proof_nodes: vec![], // Empty!
        confirmations: Some(12),
        tip_block_number: None,
    };
    
    let result = verify_eth_receipt_merkle_proof(&proof);
    assert!(result.is_err(), "empty proof nodes should fail");
    
    match result.err().unwrap() {
        EthMerkleVerifyError::EmptyProofNodes => {}
        e => panic!("expected EmptyProofNodes, got: {:?}", e),
    }
}
